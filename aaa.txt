make this way more accurate
this is bare metal i386 c code
the only main libraries available are the i386 gcc ones(not counting my external imported ones), so no math.h or stdlib.h
needs to be 32 bit code only, this is for the i386 architecture

#include "../syscall.h"
#include "../string_utils.h"
#include <float.h>
#include <stdint.h>

// Newton-Raphson sqrt for long double (no math.h)&#x20;
static long double sqrt_newton(long double N, long double eps) {
long double x = (N > 1.0L ? N : 1.0L);
while (1) {
long double next = 0.5L * (x + N / x);
if ((next > x ? next - x : x - next) < eps) break;
x = next;
}
return x;
}

// Gauss-Legendre ? to 'digits' decimals&#x20;
static long double compute_pi(int digits) {
long double eps = LDBL_EPSILON * 10.0L;       // stop threshold
long double a = 1.0L;
long double b = 1.0L / sqrt_newton(2.0L, eps);
long double t = 0.25L;
long double p = 1.0L;

for (int iter = 0; iter < 5; iter++) {
long double an = 0.5L * (a + b);
long double bn = sqrt_newton(a * b, eps);
long double delta = a - an;
t -= p * delta * delta;
p  *= 2.0L;
a = an; b = bn;
if (delta < eps) break;
}
return (a + b) * (a + b) / (4.0L * t);
}

// Entry point
void _start(void) {
syscall(SYSCALL_PRINT,
"Compute pi via Gauss-Legendre (quadratic convergence).n");
char input[8];
syscall(SYSCALL_PRINT, "Digits (1-100)? ");
syscall(SYSCALL_READLINE, input, sizeof(input));
int digits = atoi(input);
if (digits < 1 || digits > 100) {
syscall(SYSCALL_PRINT, "Enter 1-100.n");
return;
}

long double pi = compute_pi(digits);
char buf[64];
dtoa(pi, buf, digits);

syscall(SYSCALL_PRINT, buf);
syscall(SYSCALL_PRINT, "n");
}

// string_utils.c

#include "string_utils.h"
#include <stdbool.h>
size_t strlen(const char *str)
{
size_t len = 0;
while (str[len])
len++;
return len;
}

int strcmp(const char *s1, const char *s2)
{
while (*s1 && (*s1 == *s2))
{
s1++;
s2++;
}
return *(unsigned char *)s1 - *(unsigned char *)s2;
}

void strcpy(char *dest, const char *src)
{
while ((*dest++ = *src++))
;
}

// Simple tokenizer that works with a single delimiter
static char *next_token = 0;

char *strtok(char *str, const char delimiter)
{
char *token_start;

```
if (str != 0)
{
    next_token = str;
}

if (next_token == 0)
{
    return 0;
}

token_start = next_token;
while (*next_token)
{
    if (*next_token == delimiter)
    {
        *next_token = '0';
        next_token++;
        return token_start;
    }
    next_token++;
}

next_token = 0;
return token_start;
```

}

void itoa(int32_t value, char *str, int base)
{
if (base < 2 || base > 36) {
*str = '0';
return;
}

```
char *ptr = str, *ptr1, tmp_char;
uint32_t uvalue;
bool negative = false;

// Handle zero explicitly
if (value == 0) {
    *ptr++ = '0';
    *ptr = '0';
    return;
}

// Record sign and work with unsigned absolute
if (base == 10 && value < 0) {
    negative = true;
    uvalue = (uint32_t)(- (int64_t)value);
} else {
    uvalue = (uint32_t)value;
}

// Convert digits in reverse order
while (uvalue > 0) {
    uint32_t digit = uvalue % base;
    *ptr++ = "0123456789abcdefghijklmnopqrstuvwxyz"[digit];
    uvalue /= base;
}

// Add sign if negative
if (negative) {
    *ptr++ = '-';
}
*ptr = '0';

// Reverse the whole string
ptr1 = str;
for (char *end = ptr - 1; ptr1 < end; ++ptr1, --end) {
    tmp_char = *ptr1;
    *ptr1 = *end;
    *end = tmp_char;
}
```

}

void utoa(uint32_t value, char *str, int base)
{
char *ptr = str;
char *ptr1 = str;
char tmp_char;
uint32_t tmp_value;

```
if (base < 2 || base > 36)
{
    *str = '0';
    return;
}

do
{
    tmp_value = value;
    value /= base;
    *ptr++ = "0123456789abcdefghijklmnopqrstuvwxyz"[tmp_value - value * base];
} while (value);

*ptr-- = '0';

while (ptr1 < ptr)
{
    tmp_char = *ptr;
    *ptr-- = *ptr1;
    *ptr1++ = tmp_char;
}
```

}

void ftoa(float value, char *str, int precision)
{
char *ptr = str;

```
// Handle negative numbers
if (value < 0)
{
    *ptr++ = '-';
    value = -value;
}

// Extract integer part
int int_part = (int)value;
value -= int_part;

// Convert integer part to string
itoa(int_part, ptr, 10);
while (*ptr != '0') // Move pointer to the end of the integer part
    ptr++;

// Add decimal point
*ptr++ = '.';

// Convert fractional part to string
for (int i = 0; i < precision; i++)
{
    value *= 10;
    int digit = (int)value;
    *ptr++ = '0' + digit;
    value -= digit;
}

// Null-terminate the string
*ptr = '0';

// Remove trailing zeros
char *end = ptr - 1; // Start from the last character
while (end > str && *end == '0') // Remove zeros
    end--;

if (*end == '.') // Remove the decimal point if it's the last character
    end--;

*(end + 1) = '0'; // Null-terminate the string
```

}

// Very basic modf: works correctly for |value| < 2^31
static double modf(double value, double *iptr) {
// Truncate toward zero via C cast (pulls in __fixsfsi or similar, though)
long int_part = (long)value;
*iptr = (double)int_part;
return value - *iptr;
}

void dtoa(double value, char *str, int precision) {
char *ptr = str;
if (value < 0) {
*ptr++ = '-';
value = -value;
}

```
// Extract integer part using FP arithmetic only
double intpart_d;
double frac = modf(value, &intpart_d);
if (intpart_d < 1.0) {
    *ptr++ = '0';
} else {
    // find highest power of 10 <= intpart_d
    double pow10 = 1.0;
    while (pow10 * 10.0 <= intpart_d) {
        pow10 *= 10.0;
    }
    // extract digits
    while (pow10 >= 1.0) {
        int digit = (int)(intpart_d / pow10);
        *ptr++ = '0' + digit;
        intpart_d -= digit * pow10;
        pow10 /= 10.0;
    }
}

*ptr++ = '.';

// fractional digits
for (int i = 0; i < precision; i++) {
    frac *= 10.0;
    int digit = (int)frac;
    *ptr++ = '0' + digit;
    frac -= digit;
}

*ptr = '0';

// trim trailing zeros
char *end = ptr - 1;
while (end > str && *end == '0') --end;
if (*end == '.') --end;
*(end + 1) = '0';
```

}

int atoi(const char *str)
{
int result = 0;
int sign = 1;

```
// Skip leading whitespace
while (*str == ' ' || *str == 't' || *str == 'n' || *str == 'r')
    str++;

// Handle optional sign
if (*str == '-')
{
    sign = -1;
    str++;
}
else if (*str == '+')
{
    str++;
}

// Convert digits to integer
while (*str >= '0' && *str <= '9')
{
    result = result * 10 + (*str - '0');
    str++;
}

return result * sign;
```

}

float atof(const char *str)
{
float result = 0.0f;
float sign = 1.0f;
float divisor = 1.0f;

```
// Skip leading whitespace
while (*str == ' ' || *str == 't' || *str == 'n' || *str == 'r')
    str++;

// Handle optional sign
if (*str == '-')
{
    sign = -1.0f;
    str++;
}
else if (*str == '+')
{
    str++;
}

// Convert integer part
while (*str >= '0' && *str <= '9')
{
    result = result * 10.0f + (*str - '0');
    str++;
}

// Convert fractional part
if (*str == '.')
{
    str++;
    while (*str >= '0' && *str <= '9')
    {
        divisor *= 10.0f;
        result += (*str - '0') / divisor;
        str++;
    }
}

return result * sign;
```

}

double atod(const char *str) {
double result = 0.0;
double sign = 1.0;
double divisor = 1.0;

```
// Skip whitespace
while (*str == ' ' || *str == 't' || *str == 'n' || *str == 'r') {
    ++str;
}
// Optional sign
if (*str == '-') {
    sign = -1.0; ++str;
} else if (*str == '+') {
    ++str;
}

// Integer part
while (*str >= '0' && *str <= '9') {
    result = result * 10.0 + (*str - '0');
    ++str;
}

// Fractional part
if (*str == '.') {
    ++str;
    while (*str >= '0' && *str <= '9') {
        divisor *= 10.0;
        result += (*str - '0') / divisor;
        ++str;
    }
}

return result * sign;
```

}
